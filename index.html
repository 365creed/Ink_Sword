<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Seoul Rush — Zombie Mix (Forward Runner)</title>
  <style>
    html,body{margin:0;height:100%;background:#f6f7fb;font-family:system-ui,-apple-system,"Noto Sans KR",Arial}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .card{
      width:min(980px,96vw); background:#fff; border:1px solid #e7e9ef;
      border-radius:18px; box-shadow:0 12px 30px rgba(0,0,0,.06); overflow:hidden;
    }
    .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid #eef0f6}
    .title{font-weight:900;letter-spacing:-.02em}
    .hint{color:#6b7280;font-size:13px;line-height:1.25}
    .kbd{display:inline-block;padding:2px 8px;border:1px solid #d8dbe6;border-radius:999px;background:#fff;font-weight:900;color:#111827;font-size:12px}
    .stage{position:relative}
    canvas{display:block;width:100%;height:auto;background:#fff;touch-action:none}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
    .panel{
      text-align:center;background:rgba(255,255,255,.92);border:1px solid #e7e9ef;border-radius:16px;
      padding:16px; width:min(520px,90vw); box-shadow:0 14px 34px rgba(0,0,0,.10)
    }
    .panel h2{margin:0 0 6px;font-size:18px;letter-spacing:-.02em}
    .panel p{margin:0;color:#6b7280;font-size:13px;line-height:1.55}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div class="title">Seoul Rush — Human Runner vs Zombie Seoul</div>
      <div class="hint">
        이동: <span class="kbd">←</span><span class="kbd">→</span> (누르고 있기 가능) ·
        대시(회피): <span class="kbd">Shift</span> · 재시작: <span class="kbd">R</span><br/>
        모바일: 드래그/좌우 스와이프 · 탭으로 시작/재시작
      </div>
    </div>

    <div class="stage">
      <canvas id="c" width="960" height="540"></canvas>
      <div class="overlay" id="ov">
        <div class="panel" id="pn">
          <h2>시작하기</h2>
          <p>
            정면으로 달려오며 서울 풍경 속 좀비를 피하세요.<br/>
            <b>좌우 이동</b>은 연속(부드럽게), 좀비는 <b>흔들기/추격</b>합니다.<br/>
            <b>대시(회피 1회)</b>: <span class="kbd">Shift</span> (아이템으로 충전)<br/>
            시작: <span class="kbd">Space</span> 또는 화면 탭
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const ov = document.getElementById("ov");
  const pn = document.getElementById("pn");

  function fit(){
    const w = canvas.parentElement.clientWidth;
    canvas.style.height = Math.round(w * (canvas.height/canvas.width)) + "px";
  }
  window.addEventListener("resize", fit);
  fit();

  // ---------- Storage ----------
  const HI_KEY = "seoul_rush_hi_v2";
  const loadHi = () => Number(localStorage.getItem(HI_KEY) || "0");
  const saveHi = (v) => localStorage.setItem(HI_KEY, String(v));

  // ---------- helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));
  const smooth01 = (t)=>t*t*(3-2*t); // smoothstep

  // ---------- tiny audio (no external files) ----------
  // Works on user gesture only. Keep it subtle.
  let audioCtx = null;
  function beep(type="ok"){
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "square";
    o.frequency.value = (type==="hit") ? 180 : (type==="dash" ? 520 : 360);
    g.gain.value = 0.0001;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t);
    g.gain.exponentialRampToValueAtTime(0.08, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + (type==="hit"?0.12:0.08));
    o.stop(t + (type==="hit"?0.13:0.09));
  }

  // ---------- World/Perspective ----------
  const ROAD = {
    centerX: canvas.width/2,
    horizonY: 128,
    nearY: 528,
    widthNear: 420,
    widthFar: 120,
  };

  // World: x is normalized road coordinate ~ [-1..1]
  // z: 0 near, 1 far
  function project(xNorm, z){
    const p = clamp(z, 0, 1);
    const roadW = lerp(ROAD.widthNear, ROAD.widthFar, p);
    const x = ROAD.centerX + xNorm * (roadW/2);
    const y = lerp(ROAD.nearY, ROAD.horizonY, p);
    const scale = lerp(1.35, 0.22, p);
    return { x, y, scale, roadW };
  }

  // ---------- Chapters (1~4 모두 포함: 순서 연출) ----------
  const CHAPTERS = [
    { key:"hospital",  name:"응급 병원",   mood:"sirens",   bg:"hospital" },
    { key:"gwang",     name:"광화문",      mood:"stone",    bg:"gwang" },
    { key:"hangang",   name:"한강",        mood:"river",    bg:"hangang" },
    { key:"namsan",    name:"남산타워",    mood:"hill",     bg:"namsan" },
    { key:"subway",    name:"지하철",      mood:"metro",    bg:"subway" },
    { key:"palace",    name:"경복궁",      mood:"roof",     bg:"palace" },
  ];

  // ---------- Game State ----------
  const state = {
    started:false,
    running:false,
    over:false,
    last:0,
    t:0,
    dt:0,

    // forward speed: how fast objects approach (z decreases)
    speed: 0.62,
    speedMax: 1.55,
    speedGain: 0.014,

    // score
    score: 0,
    hi: loadHi(),

    // dynamic difficulty
    danger: 0,        // 0..1
    spawnTimer: 0,
    spawnEvery: 0.92,

    // zombies + items
    mobs: [],
    items: [],        // dash-charge pickups
    particles: [],

    // background objects (big silhouettes coming toward camera)
    bgObjs: [],

    // chapter system
    chapterIndex: 0,
    chapterTime: 0,
    chapterLength: 18,     // seconds per chapter
    chapterBanner: 0,      // 0..1 fade
    bannerText: "",

    // hit effects
    hitFlash: 0,           // 0..1
    shake: 0,              // px
  };

  const input = {
    left:false,
    right:false,
    dash:false,
    pointerDown:false,
    pointerX: 0,
    dragging:false,
    lastPointerX: 0,
  };

  const player = {
    x: 0,           // normalized road x [-1..1]
    vx: 0,
    dashCharge: 1,  // 회피 1회(아이템으로 충전)
    dashCD: 0,
    invuln: 0,
  };

  // ---------- Content: Zombies ----------
  const ZOMBIE_TYPES = [
    { key:"basic",  w:44, h:80,  style:"basic"  },
    { key:"hat",    w:48, h:86,  style:"hat"    },
    { key:"mask",   w:46, h:82,  style:"mask"   },
    { key:"nurse",  w:46, h:84,  style:"nurse"  },
    { key:"runner", w:42, h:76,  style:"runner" },
  ];

  // Spawn big background silhouettes by chapter
  function spawnBgSilhouette(kind){
    // Spawn at far z and move toward viewer; placed off-road sides or skyline
    const side = Math.random()<0.5 ? -1 : 1;
    const xNorm = side * rand(1.0, 1.8);
    state.bgObjs.push({
      kind,
      xNorm,
      z: rand(0.86, 1.25),
      wob: rand(0, Math.PI*2),
    });
  }

  function spawnZombie(){
    const d = state.danger;
    const poolMax = Math.max(2, Math.floor(2 + d*(ZOMBIE_TYPES.length-2)));
    const type = ZOMBIE_TYPES[randi(0, poolMax)];

    // spawn near center-ish but anywhere on road
    const x = rand(-0.95, 0.95);
    const z = rand(0.86, 1.12);

    // AI behavior: some sway, some chase
    const behaviorRoll = Math.random();
    const behavior = (behaviorRoll < 0.45) ? "sway" : (behaviorRoll < 0.85 ? "chase" : "zigzag");

    state.mobs.push({
      type,
      x,
      z,
      vx: 0,
      swayAmp: rand(0.05, 0.16),
      swaySpd: rand(1.8, 3.4),
      phase: rand(0, Math.PI*2),
      behavior,
      // chase tuning
      chaseAggro: rand(0.35, 0.85),
      // size jitter
      bob: rand(0, Math.PI*2),
    });
  }

  function spawnDashItem(){
    // pickup that refills dashCharge by 1 up to 2
    state.items.push({
      x: rand(-0.9, 0.9),
      z: rand(0.9, 1.2),
      wob: rand(0, Math.PI*2),
    });
  }

  // ---------- Overlay ----------
  function showOverlay(title, html){
    ov.style.display = "flex";
    pn.querySelector("h2").textContent = title;
    pn.querySelector("p").innerHTML = html;
  }
  function hideOverlay(){ ov.style.display = "none"; }

  function setChapter(idx, showBanner=true){
    state.chapterIndex = (idx + CHAPTERS.length) % CHAPTERS.length;
    state.chapterTime = 0;

    const c = CHAPTERS[state.chapterIndex];
    state.bannerText = c.name;
    if(showBanner){
      state.chapterBanner = 1;
    }

    // Immediately add some silhouettes for that chapter
    for(let i=0;i<4;i++) spawnBgSilhouette(c.bg);
  }

  function reset(){
    state.started=false;
    state.running=false;
    state.over=false;
    state.last=0;
    state.t=0;
    state.score=0;

    state.speed=0.62;
    state.danger=0;
    state.spawnTimer=0;
    state.spawnEvery=0.92;

    state.mobs.length=0;
    state.items.length=0;
    state.particles.length=0;
    state.bgObjs.length=0;

    state.hitFlash=0;
    state.shake=0;

    player.x=0; player.vx=0;
    player.dashCharge=1;
    player.dashCD=0;
    player.invuln=0;

    setChapter(0, true);

    showOverlay(
      "시작하기",
      `서울 풍경이 <b>정면으로 다가오고</b>, 좀비가 <b>흔들/추격</b>합니다.<br/>
       이동: <span class="kbd">←</span><span class="kbd">→</span> 또는 드래그 ·
       대시(회피): <span class="kbd">Shift</span><br/>
       시작: <span class="kbd">Space</span> / 화면 탭`
    );
  }

  function startGame(){
    state.started=true;
    state.running=true;
    state.over=false;
    hideOverlay();

    // unlock audio on gesture
    if(!audioCtx){
      try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch{}
    }
    beep("ok");
  }

  function gameOver(){
    state.running=false;
    state.over=true;

    const s = Math.floor(state.score);
    if(s > state.hi){ state.hi = s; saveHi(state.hi); }

    showOverlay(
      "GAME OVER",
      `점수: <b>${s}</b> · 최고: <b>${state.hi}</b><br/>
       다시 시작: <span class="kbd">R</span> 또는 화면 탭`
    );
  }

  // ---------- Input ----------
  window.addEventListener("keydown", (e)=>{
    if(e.code==="ArrowLeft"){ e.preventDefault(); if(!state.started) startGame(); input.left=true; }
    if(e.code==="ArrowRight"){ e.preventDefault(); if(!state.started) startGame(); input.right=true; }
    if(e.code==="ShiftLeft"||e.code==="ShiftRight"){ e.preventDefault(); if(!state.started) startGame(); input.dash=true; }
    if(e.code==="Space"){ e.preventDefault(); if(!state.started) startGame(); }
    if(e.code==="KeyR"){ e.preventDefault(); reset(); }
  }, {passive:false});
  window.addEventListener("keyup", (e)=>{
    if(e.code==="ArrowLeft") input.left=false;
    if(e.code==="ArrowRight") input.right=false;
    if(e.code==="ShiftLeft"||e.code==="ShiftRight") input.dash=false;
  });

  // pointer controls: drag to move smoothly
  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if(!state.started){ startGame(); return; }
    if(state.over){ reset(); return; }

    input.pointerDown=true;
    input.dragging=true;
    input.lastPointerX = e.clientX;
    canvas.setPointerCapture(e.pointerId);
  }, {passive:false});

  canvas.addEventListener("pointermove", (e)=>{
    if(!input.pointerDown) return;
    const dx = e.clientX - input.lastPointerX;
    input.lastPointerX = e.clientX;

    // convert pixel movement to normalized road x
    const rect = canvas.getBoundingClientRect();
    const ndx = dx / rect.width;
    player.x += ndx * 2.0; // sensitivity
    player.x = clamp(player.x, -1.0, 1.0);
  });

  canvas.addEventListener("pointerup", (e)=>{
    input.pointerDown=false;
    input.dragging=false;
  });
  canvas.addEventListener("pointercancel", ()=>{
    input.pointerDown=false;
    input.dragging=false;
  });

  ov.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if(!state.started) startGame();
    else if(state.over) reset();
  }, {passive:false});

  // ---------- Effects ----------
  function vibrate(ms){
    try{ if(navigator.vibrate) navigator.vibrate(ms); }catch{}
  }
  function spawnHitParticles(){
    for(let i=0;i<18;i++){
      state.particles.push({
        x: player.x + rand(-0.1,0.1),
        z: 0.06 + rand(-0.02,0.02),
        vx: rand(-0.8,0.8),
        vz: rand(0.35, 1.15),
        life: rand(0.25, 0.5),
        t: 0,
      });
    }
  }
  function spawnPickupParticles(x){
    for(let i=0;i<14;i++){
      state.particles.push({
        x: x + rand(-0.1,0.1),
        z: 0.10 + rand(0.0,0.05),
        vx: rand(-0.6,0.6),
        vz: rand(0.25, 0.8),
        life: rand(0.22, 0.42),
        t: 0,
      });
    }
  }

  // ---------- Collision / gameplay rules ----------
  // Player "hit zone" is near camera (z<=hitZ). If mob overlaps in x and gets close => hit.
  function hitTest(m){
    const hitZ = 0.095;
    if(m.z > hitZ) return false;
    // x overlap threshold grows as things get closer (scale bigger)
    const p = project(m.x, clamp(m.z, 0, 1));
    const thresh = lerp(0.18, 0.32, 1 - clamp(m.z/0.2, 0, 1));
    return Math.abs(m.x - player.x) < thresh;
  }

  function itemTest(it){
    const hitZ = 0.11;
    if(it.z > hitZ) return false;
    return Math.abs(it.x - player.x) < 0.26;
  }

  function tryDash(){
    if(player.dashCD > 0) return;
    if(player.invuln > 0) return;
    if(player.dashCharge <= 0) return;

    player.dashCharge -= 1;
    player.invuln = 0.55; // brief i-frames
    player.dashCD = 0.35;

    state.shake = 6;
    beep("dash");
    vibrate(20);
  }

  // ---------- Update ----------
  function update(dt){
    state.dt = dt;
    state.t += dt;

    // fade banner
    if(state.chapterBanner > 0){
      state.chapterBanner = Math.max(0, state.chapterBanner - dt*0.6);
    }

    state.hitFlash = Math.max(0, state.hitFlash - dt*2.8);
    state.shake = Math.max(0, state.shake - dt*18);

    if(!state.running) return;

    // score grows with speed and time
    state.score += dt * (160 + state.speed*300);

    // difficulty (0..1)
    state.danger = clamp(state.score / 1600, 0, 1);

    // speed up
    state.speed = clamp(state.speed + state.speedGain*dt, 0, state.speedMax);

    // spawn rates up
    state.spawnEvery = lerp(0.95, 0.50, state.danger);

    // chapter progression
    state.chapterTime += dt;
    if(state.chapterTime >= state.chapterLength){
      setChapter(state.chapterIndex + 1, true);
    }

    // background silhouettes spawn more over time
    if(Math.random() < dt * (0.9 + state.danger*1.8)){
      spawnBgSilhouette(CHAPTERS[state.chapterIndex].bg);
    }

    // occasionally spawn dash item
    if(Math.random() < dt * (0.10 + (1 - state.danger)*0.08)){
      spawnDashItem();
    }

    // keyboard smooth movement (if not dragging)
    if(!input.dragging){
      const accel = 3.6;           // normalized units per s^2
      const maxV = 2.2;
      if(input.left)  player.vx -= accel * dt;
      if(input.right) player.vx += accel * dt;
      // friction
      player.vx *= Math.pow(0.001, dt); // strong damping
      player.vx = clamp(player.vx, -maxV, maxV);
      player.x += player.vx * dt;
      player.x = clamp(player.x, -1.0, 1.0);
    } else {
      // if dragging, damp velocity
      player.vx *= Math.pow(0.001, dt);
    }

    // dash
    if(input.dash) tryDash();
    player.dashCD = Math.max(0, player.dashCD - dt);
    player.invuln = Math.max(0, player.invuln - dt);

    // spawn mobs
    state.spawnTimer += dt;
    if(state.spawnTimer >= state.spawnEvery){
      state.spawnTimer = 0;

      // spawn 1..2 mobs depending on danger
      spawnZombie();
      if(state.danger > 0.45 && Math.random() < 0.33){
        spawnZombie();
      }
    }

    // move mobs toward camera
    for(const m of state.mobs){
      m.z -= state.speed * dt;

      // behavior AI (C)
      m.phase += dt * m.swaySpd;
      m.bob += dt * 8;

      if(m.behavior === "sway"){
        const sway = Math.sin(m.phase) * m.swayAmp;
        m.x += sway * dt;
      } else if(m.behavior === "zigzag"){
        const sway = Math.sign(Math.sin(m.phase)) * m.swayAmp * 0.75;
        m.x += sway * dt * 1.8;
      } else { // chase
        // steer toward player x
        const desire = (player.x - m.x) * (0.9 + m.chaseAggro*1.6);
        m.x += desire * dt * (0.65 + state.danger*0.55);
        // plus small wobble
        m.x += Math.sin(m.phase) * m.swayAmp * 0.25 * dt;
      }

      // keep within road boundaries slightly wider than player
      m.x = clamp(m.x, -1.05, 1.05);
    }

    // move items + bg
    for(const it of state.items){
      it.z -= state.speed * dt * 0.95;
      it.wob += dt * 6;
    }
    for(const b of state.bgObjs){
      b.z -= state.speed * dt * 0.75;
      b.wob += dt * 1.4;
    }

    // particles
    for(const p of state.particles){
      p.t += dt;
      p.x += p.vx * dt;
      p.z -= state.speed * dt * 0.2; // keep near-ish
      p.z += p.vz * dt;
    }
    state.particles = state.particles.filter(p => p.t < p.life);

    // pickups
    for(let i=state.items.length-1;i>=0;i--){
      const it = state.items[i];
      if(itemTest(it)){
        state.items.splice(i,1);
        player.dashCharge = Math.min(2, player.dashCharge + 1);
        spawnPickupParticles(it.x);
        beep("ok");
        vibrate(12);
      }
    }

    // collisions
    if(player.invuln <= 0){
      for(const m of state.mobs){
        if(hitTest(m)){
          // hit => game over (or you can convert to "1 life" later)
          state.hitFlash = 1;
          state.shake = 10;
          beep("hit");
          vibrate(60);
          spawnHitParticles();
          gameOver();
          break;
        }
      }
    }

    // cleanup passed objects
    state.mobs = state.mobs.filter(m => m.z > -0.2);
    state.items = state.items.filter(i => i.z > -0.2);
    state.bgObjs = state.bgObjs.filter(b => b.z > -0.25);
  }

  // ---------- Draw ----------
  function draw(){
    // camera shake
    const sx = (Math.random()*2-1) * state.shake;
    const sy = (Math.random()*2-1) * state.shake;

    ctx.save();
    ctx.translate(sx, sy);

    // base
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawSky();
    drawFarSeoul();
    drawBigSilhouettes(); // A (진짜 배경 오브젝트)
    drawRoad();
    drawItems();
    drawMobs();
    drawPlayer();
    drawParticles();
    drawHUD();
    drawChapterBanner();

    // hit flash overlay
    if(state.hitFlash > 0){
      ctx.fillStyle = `rgba(239,68,68,${0.18 * state.hitFlash})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // vignette
    ctx.fillStyle = "rgba(15,23,42,0.05)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.restore();
  }

  function drawSky(){
    ctx.fillStyle = "#f4f6fb";
    ctx.fillRect(0,0,canvas.width,190);
    ctx.fillStyle = "#f8fafc";
    ctx.fillRect(0,190,canvas.width,180);

    // simple clouds
    ctx.fillStyle = "rgba(203,213,225,0.55)";
    cloud(140, 86, 1.2);
    cloud(360, 64, 0.95);
    cloud(780, 88, 1.1);

    function cloud(x,y,s){
      ctx.save();
      ctx.translate(x,y);
      ctx.scale(s,s);
      ctx.beginPath();
      ctx.arc(-28,0,18,0,Math.PI*2);
      ctx.arc(-6,-10,22,0,Math.PI*2);
      ctx.arc(18,0,16,0,Math.PI*2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  function drawFarSeoul(){
    // distant skyline blocks
    ctx.fillStyle = "#e9edf7";
    const baseY = 238;
    let x = -50;
    while (x < canvas.width+70){
      const w = 60 + ((x*17)%50+50)%50;
      const h = 24 + ((x*13)%62+62)%62;
      ctx.fillRect(x, baseY - h, w, h);
      x += w + 18;
    }

    // distant namsan hint
    ctx.fillStyle = "#dfe6f4";
    ctx.fillRect(720, baseY - 110, 10, 110);
    ctx.beginPath(); ctx.roundRect(705, baseY - 145, 40, 34, 10); ctx.fill();
    ctx.fillRect(724, baseY - 168, 3, 23);
  }

  function drawRoad(){
    const hY = ROAD.horizonY;
    const nY = ROAD.nearY;

    // road polygon
    ctx.fillStyle = "#eef2ff";
    ctx.beginPath();
    ctx.moveTo(ROAD.centerX - ROAD.widthFar/2, hY);
    ctx.lineTo(ROAD.centerX + ROAD.widthFar/2, hY);
    ctx.lineTo(ROAD.centerX + ROAD.widthNear/2, nY);
    ctx.lineTo(ROAD.centerX - ROAD.widthNear/2, nY);
    ctx.closePath();
    ctx.fill();

    // edges
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(ROAD.centerX - ROAD.widthFar/2, hY);
    ctx.lineTo(ROAD.centerX - ROAD.widthNear/2, nY);
    ctx.moveTo(ROAD.centerX + ROAD.widthFar/2, hY);
    ctx.lineTo(ROAD.centerX + ROAD.widthNear/2, nY);
    ctx.stroke();

    // lane guide lines (just visual, no fixed lanes in gameplay now)
    drawDivider(-0.33);
    drawDivider( 0.33);

    function drawDivider(nx){
      const dashCount = 14;
      for(let i=0;i<dashCount;i++){
        const phase = (state.t * state.speed * 0.58) % 1;
        const zz = (i/dashCount + phase) % 1;
        const a = project(nx, zz);
        const b = project(nx, clamp(zz + 0.06, 0, 1));
        ctx.strokeStyle = "rgba(148,163,184,0.55)";
        ctx.lineWidth = Math.max(1.2, a.scale*2.1);
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }
  }

  // A: real big silhouettes by chapter, placed on sides / skyline and coming toward you
  function drawBigSilhouettes(){
    // draw far->near (sort by z desc)
    const list = [...state.bgObjs].sort((a,b)=>b.z-a.z);

    for(const o of list){
      const z = clamp(o.z, 0, 1);
      const p = project(o.xNorm, z);
      const s = p.scale * 2.2; // big

      // fade in as approaching
      const fade = clamp((1 - z) * 1.15, 0, 1);

      ctx.save();
      ctx.globalAlpha = 0.80 * fade;
      ctx.translate(p.x, p.y);
      ctx.scale(s, s);

      // silhouette color changes a bit by chapter mood (subtle)
      ctx.fillStyle = "#dfe6f4";
      ctx.strokeStyle = "#d7deee";
      ctx.lineWidth = 2;

      switch(o.kind){
        case "hospital": drawHospitalSil(); break;
        case "gwang": drawGwangSil(); break;
        case "hangang": drawBridgeSil(); break;
        case "namsan": drawTowerSil(); break;
        case "subway": drawSubwaySil(); break;
        case "palace": drawPalaceSil(); break;
        default: drawTowerSil();
      }

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function drawHospitalSil(){
      // big block + ER sign
      ctx.beginPath(); ctx.roundRect(-110, -90, 220, 130, 18); ctx.fill();
      ctx.fillStyle = "#d7deee";
      ctx.beginPath(); ctx.roundRect(-90, -70, 60, 100, 16); ctx.fill();
      ctx.beginPath(); ctx.roundRect( 30, -70, 60, 100, 16); ctx.fill();
      ctx.fillStyle = "#cbd5e1";
      ctx.beginPath(); ctx.roundRect(-52, -40, 104, 70, 14); ctx.fill();
      ctx.fillStyle = "#dfe6f4";
      ctx.font = "900 18px system-ui";
      ctx.fillText("ER", -18, 5);
    }
    function drawGwangSil(){
      // arch + roof
      ctx.beginPath(); ctx.roundRect(-120, -60, 240, 90, 16); ctx.fill();
      ctx.fillStyle = "#d7deee";
      ctx.beginPath();
      ctx.moveTo(-136, -60); ctx.lineTo(0, -116); ctx.lineTo(136, -60);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = "#cbd5e1";
      ctx.fillRect(-80, -30, 160, 20);
      ctx.fillStyle = "#dfe6f4";
      ctx.fillRect(-70, -10, 140, 40);
      ctx.fillStyle = "#cbd5e1";
      ctx.fillRect(-20, 6, 40, 24);
    }
    function drawBridgeSil(){
      ctx.strokeStyle = "#cbd5e1";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(-140, 20);
      ctx.quadraticCurveTo(0, -90, 140, 20);
      ctx.stroke();
      ctx.strokeStyle = "#d7deee";
      ctx.lineWidth = 14;
      ctx.beginPath(); ctx.moveTo(-160, 20); ctx.lineTo(160, 20); ctx.stroke();
      ctx.fillStyle = "#cbd5e1";
      ctx.fillRect(-120, 20, 18, 70);
      ctx.fillRect( 102, 20, 18, 70);
    }
    function drawTowerSil(){
      ctx.fillRect(-10, -140, 20, 190);
      ctx.fillStyle = "#cbd5e1";
      ctx.beginPath(); ctx.roundRect(-55, -170, 110, 60, 18); ctx.fill();
      ctx.fillStyle = "#d7deee";
      ctx.fillRect(-3, -210, 6, 40);
      // hill
      ctx.fillStyle = "#e2e8f0";
      ctx.beginPath();
      ctx.moveTo(-170, 90);
      ctx.quadraticCurveTo(0, -20, 170, 90);
      ctx.closePath();
      ctx.fill();
    }
    function drawSubwaySil(){
      ctx.fillStyle = "#dfe6f4";
      ctx.beginPath(); ctx.roundRect(-120, -90, 240, 160, 30); ctx.fill();
      ctx.fillStyle = "#cbd5e1";
      ctx.beginPath(); ctx.roundRect(-90, -60, 180, 70, 22); ctx.fill();
      ctx.fillStyle = "#dfe6f4";
      ctx.fillRect(-120, 40, 240, 18);
      ctx.fillStyle = "#cbd5e1";
      ctx.beginPath(); ctx.arc(-70, 80, 18, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( 70, 80, 18, 0, Math.PI*2); ctx.fill();
    }
    function drawPalaceSil(){
      ctx.fillStyle = "#dfe6f4";
      ctx.fillRect(-160, 10, 320, 26);
      ctx.fillStyle = "#cbd5e1";
      ctx.beginPath();
      ctx.moveTo(-170, 10);
      ctx.lineTo(0, -80);
      ctx.lineTo(170, 10);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#d7deee";
      ctx.fillRect(-110, -10, 220, 16);
      ctx.fillStyle = "#dfe6f4";
      ctx.fillRect(-120, 0, 40, 70);
      ctx.fillRect( 80, 0, 40, 70);
      ctx.fillStyle = "#cbd5e1";
      ctx.fillRect(-18, 12, 36, 46);
    }
  }

  function drawItems(){
    // far->near
    const list = [...state.items].sort((a,b)=>b.z-a.z);
    for(const it of list){
      const p = project(it.x, clamp(it.z,0,1));
      const s = p.scale * 1.05;
      const bob = Math.sin(it.wob)*3;

      ctx.save();
      ctx.translate(p.x, p.y + bob);
      ctx.scale(s, s);

      // glow
      ctx.fillStyle = "rgba(59,130,246,0.16)";
      ctx.beginPath(); ctx.ellipse(0, 18, 34, 10, 0, 0, Math.PI*2); ctx.fill();

      // battery icon (dash charge)
      ctx.fillStyle = "#3b82f6";
      ctx.beginPath(); ctx.roundRect(-16, -30, 32, 42, 10); ctx.fill();
      ctx.fillStyle = "#e5e7eb";
      ctx.fillRect(-6, -38, 12, 8);
      ctx.fillStyle = "#111827";
      ctx.font = "900 12px system-ui";
      ctx.fillText("D", -5, -4);

      ctx.restore();
    }
  }

  function drawMobs(){
    const list = [...state.mobs].sort((a,b)=>b.z-a.z);
    for(const m of list){
      drawZombie(m);
    }
  }

  function drawZombie(m){
    const z = clamp(m.z,0,1);
    const p = project(m.x, z);
    const s = p.scale * 1.20;
    const bob = Math.sin(m.bob)*2;

    ctx.save();
    ctx.translate(p.x, p.y + bob);
    ctx.scale(s, s);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.beginPath();
    ctx.ellipse(0, 20, 30, 9, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "#16a34a";
    ctx.beginPath(); ctx.roundRect(-22, -78, 44, 78, 12); ctx.fill();

    // head
    ctx.fillStyle = "#22c55e";
    ctx.beginPath(); ctx.roundRect(-20, -114, 40, 38, 12); ctx.fill();

    // eyes
    ctx.fillStyle = "#111827";
    dot(-8, -96, 3);
    dot( 8, -96, 3);

    // mouth
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(-10, -84); ctx.lineTo(10, -84); ctx.stroke();

    // arms (animated)
    const swing = Math.sin(state.t*10 + m.phase) * 6;
    ctx.fillStyle = "#15803d";
    ctx.beginPath(); ctx.roundRect(-40, -60 + swing*0.2, 20, 10, 6); ctx.fill();
    ctx.beginPath(); ctx.roundRect( 20, -52 - swing*0.2, 20, 10, 6); ctx.fill();

    // accessories
    if(m.type.style==="hat"){
      ctx.fillStyle="#111827";
      ctx.beginPath(); ctx.ellipse(0,-118,32,6,0,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.roundRect(-14,-140,28,22,10); ctx.fill();
    } else if(m.type.style==="mask"){
      ctx.fillStyle="#e5e7eb";
      ctx.beginPath(); ctx.roundRect(-18,-90,36,16,8); ctx.fill();
      ctx.strokeStyle="rgba(17,24,39,0.35)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(-18,-82); ctx.lineTo(18,-82); ctx.stroke();
    } else if(m.type.style==="nurse"){
      ctx.fillStyle="#e5e7eb";
      ctx.beginPath(); ctx.roundRect(-18,-136,36,18,8); ctx.fill();
      ctx.fillStyle="#ef4444";
      ctx.fillRect(-3,-132,6,10);
      ctx.fillRect(-8,-127,16,6);
    } else if(m.type.style==="runner"){
      ctx.fillStyle="#3b82f6";
      ctx.beginPath(); ctx.roundRect(-20,-106,40,10,8); ctx.fill();
    }

    // feet
    ctx.fillStyle="#065f46";
    ctx.beginPath(); ctx.roundRect(-18,-6,16,10,5); ctx.fill();
    ctx.beginPath(); ctx.roundRect( 2,-6,16,10,5); ctx.fill();

    ctx.restore();
  }

  function drawPlayer(){
    // always near camera, projected with near z
    const p = project(player.x*0.92, 0.04);
    const s = 1.12;

    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.scale(s, s);

    // invuln glow
    if(player.invuln>0){
      ctx.fillStyle = `rgba(59,130,246,${0.18 + 0.22*Math.sin(state.t*24)})`;
      ctx.beginPath();
      ctx.ellipse(0, 14, 38, 18, 0, 0, Math.PI*2);
      ctx.fill();
    }

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.14)";
    ctx.beginPath(); ctx.ellipse(0, 24, 32, 9, 0, 0, Math.PI*2); ctx.fill();

    // body
    ctx.fillStyle = "#111827";
    ctx.beginPath(); ctx.roundRect(-18,-74,36,64,14); ctx.fill();

    // shirt
    ctx.fillStyle = "#f8fafc";
    ctx.beginPath(); ctx.roundRect(-16,-54,32,36,10); ctx.fill();

    // head
    ctx.fillStyle = "#f2c9a0";
    ctx.beginPath(); ctx.roundRect(-16,-108,32,36,14); ctx.fill();

    // hair
    ctx.fillStyle = "#111827";
    ctx.beginPath(); ctx.roundRect(-16,-110,32,18,12); ctx.fill();

    // eyes
    ctx.fillStyle = "#111827";
    dot(-6, -94, 2.4); dot(6, -94, 2.4);

    // mouth
    ctx.strokeStyle = "rgba(17,24,39,0.45)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-4,-86); ctx.lineTo(4,-86); ctx.stroke();

    // arms & legs
    const walk = state.running ? Math.sin(state.t*10)*5 : 0;
    ctx.fillStyle = "#111827";
    ctx.beginPath(); ctx.roundRect(-28,-52 + walk,12,30,8); ctx.fill();
    ctx.beginPath(); ctx.roundRect( 16,-52 - walk,12,30,8); ctx.fill();

    ctx.beginPath(); ctx.roundRect(-14,-10,12,28,8); ctx.fill();
    ctx.beginPath(); ctx.roundRect( 2,-10,12,28,8); ctx.fill();

    // shoes
    ctx.fillStyle = "#0f172a";
    ctx.beginPath(); ctx.roundRect(-16, 16, 16, 8, 5); ctx.fill();
    ctx.beginPath(); ctx.roundRect(0, 16, 16, 8, 5); ctx.fill();

    ctx.restore();
  }

  function drawParticles(){
    for(const p of state.particles){
      const a = 1 - (p.t/p.life);
      const pr = project(p.x, clamp(p.z,0,1));
      const s = pr.scale * 0.6;
      ctx.save();
      ctx.globalAlpha = a * 0.85;
      ctx.translate(pr.x, pr.y);
      ctx.scale(s, s);
      ctx.fillStyle = "#cbd5e1";
      ctx.beginPath();
      ctx.arc(0, 0, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.globalAlpha = 1;
    }
  }

  function drawHUD(){
    ctx.save();
    ctx.fillStyle = "#111827";
    ctx.font = "900 18px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`SCORE ${Math.floor(state.score)}`, 18, 30);

    ctx.fillStyle = "#6b7280";
    ctx.font = "900 13px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`HI ${state.hi}`, 18, 52);

    // dash
    ctx.fillStyle = "#111827";
    ctx.font = "900 13px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`DASH ${player.dashCharge}/2`, 18, 74);

    // chapter label
    const c = CHAPTERS[state.chapterIndex];
    ctx.fillStyle = "#94a3b8";
    ctx.font = "900 12px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(`${c.name} · 난이도 ${Math.floor(state.danger*100)}%`, 18, 94);

    ctx.restore();
  }

  function drawChapterBanner(){
    if(state.chapterBanner <= 0) return;
    const a = smooth01(clamp(state.chapterBanner,0,1));
    ctx.save();
    ctx.globalAlpha = a;

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.strokeStyle = "rgba(203,213,225,0.9)";
    ctx.lineWidth = 2;

    const w = 320, h = 54;
    const x = canvas.width/2 - w/2;
    const y = 92;

    ctx.beginPath(); ctx.roundRect(x, y, w, h, 16); ctx.fill(); ctx.stroke();
    ctx.fillStyle = "#111827";
    ctx.font = "900 18px system-ui,-apple-system,'Noto Sans KR',Arial";
    ctx.fillText(state.bannerText, canvas.width/2 - ctx.measureText(state.bannerText).width/2, y+34);

    ctx.restore();
  }

  function dot(x,y,r){
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  // ---------- Main loop ----------
  function loop(ts){
    if(!state.last) state.last = ts;
    const dt = clamp((ts - state.last)/1000, 0, 0.033);
    state.last = ts;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ---------- Start ----------
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
